/* $Id: t_context.h,v 1.43.2.3 2002/11/19 12:01:29 keithw Exp $ */

/*
 * Mesa 3-D graphics library
 * Version:  4.1
 *
 * Copyright (C) 1999-2002  Brian Paul   All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * BRIAN PAUL BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
 * AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

/**
 * \file t_context.h
 * \brief TnL module datatypes and definitions.
 * \author Keith Whitwell
 */

#ifndef _T_CONTEXT_H
#define _T_CONTEXT_H

#include "glheader.h"
#include "mtypes.h"



#define MAX_PIPELINE_STAGES     30


/**
 * Extend the VERT_ATTRIB_ definitions from mtypes.h.  Don't bother
 * defining the VERT_BIT equivalents as we have to use 2 32bit bitsets
 * to talk about these now.
 */ 
#define VERT_ATTRIB_MAT_FRONT_AMBIENT           (MAT_ATTRIB_FRONT_AMBIENT+16)
#define VERT_ATTRIB_MAT_FRONT_DIFFUSE           (MAT_ATTRIB_FRONT_DIFFUSE+16)
#define VERT_ATTRIB_MAT_FRONT_SPECULAR          (MAT_ATTRIB_FRONT_SPECULAR+16)
#define VERT_ATTRIB_MAT_FRONT_EMISSION          (MAT_ATTRIB_FRONT_EMISSION+16)
#define VERT_ATTRIB_MAT_FRONT_SHININESS         (MAT_ATTRIB_FRONT_SHININESS+16)
#define VERT_ATTRIB_MAT_FRONT_INDEXES           (MAT_ATTRIB_FRONT_INDEXES+16)
#define VERT_ATTRIB_MAT_BACK_AMBIENT            (MAT_ATTRIB_BACK_AMBIENT+16)
#define VERT_ATTRIB_MAT_BACK_DIFFUSE            (MAT_ATTRIB_BACK_DIFFUSE+16)
#define VERT_ATTRIB_MAT_BACK_SPECULAR           (MAT_ATTRIB_BACK_SPECULAR+16)
#define VERT_ATTRIB_MAT_BACK_EMISSION           (MAT_ATTRIB_BACK_EMISSION+16)
#define VERT_ATTRIB_MAT_BACK_SHININESS          (MAT_ATTRIB_BACK_SHININESS+16)
#define VERT_ATTRIB_MAT_BACK_INDEXES            (MAT_ATTRIB_BACK_INDEXES+16)
#define VERT_ATTRIB_INDEX                       28 /* not naturally a float */
#define VERT_ATTRIB_EDGEFLAG                    29 /* not naturally a float */
#define VERT_ATTRIB_POINTSIZE                   30 
#define VERT_ATTRIB_BACK_COLOR0                 31 
#define VERT_ATTRIB_BACK_COLOR1                 32 
#define VERT_ATTRIB_BACK_INDEX                  33 /* not naturally a float */
#define TNL_ATTRIB_MAX                          34

#define TEST_BIT( bset, bit ) (bset[bit/32] & (1<<(bit&31)))
#define SET_BIT( bset, bit )  (bset[bit/32] |= (1<<(bit&31)))
#define CLEAR_BIT( bset, bit )  (bset[bit/32] &= ~(1<<(bit&31)))


#define TNL_EVAL_COORD1       0x1
#define TNL_EVAL_COORD2       0x2
#define TNL_EVAL_POINT1       0x4
#define TNL_EVAL_POINT2       0x8


/* Numbers for sizing immediate structs.
 */
#define IMM_MAX_COPIED_VERTS  3


/* Storage for vertices generated by.
 */
struct vertex_block
{
   GLuint refcount;
   GLuint vertex_format[2];
   GLuint vertex_size;
   GLuint block_size;
   GLubyte verts[1];
};


#define PRIM_MODE_MASK  0xff    /* Extract the actual primitive */
#define PRIM_BEGIN      0x100	/* The prim starts here (not wrapped) */
#define PRIM_END        0x200	/* The prim ends in this VB (does not wrap) */
#define PRIM_PARITY     0x400	/* The prim wrapped on an odd number of verts */

struct tnl_prim 
{
   GLuint start;
   GLuint end;
   GLuint flags;
};


/**
 * Contains the current state of a running pipeline.
 */
struct vertex_buffer
{
   /* Constant over life of the vertex_buffer.
    */
   GLuint Size;

   /* Constant over the pipeline.
    */
   GLuint     Count;		              /* for everything except Elts */
   GLuint     FirstClipped;	              /* temp verts for clipping */

   /* Pointers to current data.
    */
   GLuint                  *Elts;		                
   struct gl_client_array  *EyePtr;		                
   struct gl_client_array  *ClipPtr;	                
   struct gl_client_array  *NdcPtr;                         
   GLubyte                 *ClipMask;		        
   GLfloat                 *NormalLengthPtr;	        
   struct gl_client_array  *PointSizePtr;	/* why not just a float *? */

   struct tnl_prim  *Primitive;	              /* primitive descriptors */
   GLuint           NrPrimitives;	      /* nr */

   struct gl_client_array *Attrib[TNL_ATTRIB_MAX]; 
   /* All other vertex data.  Edgeflag & Index are included in here as
    * float arrays.  This may have to change later.
    */

   GLuint AttribActive;
   /* Bitmap: Which arrays are non-zero?
    */

   GLuint LastClipped;
   /* Private data from _tnl_render_stage that has no business being
    * in this struct.
    */

};



/* Describes an individual operation on the pipeline.
 */
struct tnl_pipeline_stage {
   const char *name;
   GLuint check_state;		/* All state referenced in check() --
				 * When is the pipeline_stage struct
				 * itself invalidated?  Must be
				 * constant.
				 */

   /* Usually constant or set by the 'check' callback:
    */
   GLuint run_state;		/* All state referenced in run() --
				 * When is the cached output of the
				 * stage invalidated?
				 */

   GLboolean active;		/* True if runnable in current state */
   GLuint inputs[2];		/* VERT_* inputs to the stage */
   GLuint outputs[2];		/* VERT_* outputs of the stage */

   /* Set in _tnl_run_pipeline():
    */
   GLuint changed_inputs[2];	/* Generated value -- inputs to the
				 * stage that have changed since last
				 * call to 'run'.
				 */

   /* Private data for the pipeline stage:
    */
   void *privatePtr;

   /* Free private data.  May not be null.
    */
   void (*destroy)( struct tnl_pipeline_stage * );

   /* Called from _tnl_validate_pipeline().  Must update all fields in
    * the pipeline_stage struct for the current state.
    */
   void (*check)( GLcontext *ctx, struct tnl_pipeline_stage * );

   /* Called from _tnl_run_pipeline().  The stage.changed_inputs value
    * encodes all inputs to thee struct which have changed.  If
    * non-zero, recompute all affected outputs of the stage, otherwise
    * execute any 'sideeffects' of the stage.
    *
    * Return value: GL_TRUE - keep going
    *               GL_FALSE - finished pipeline
    */
   GLboolean (*run)( GLcontext *ctx, struct tnl_pipeline_stage * );
};


struct tnl_pipeline {
   GLuint build_state_trigger;	  /* state changes which require build */
   GLuint build_state_changes;    /* state changes since last build */
   GLuint run_state_changes;	  /* state changes since last run */
   GLuint run_input_changes[2];	  /* VERT_* changes since last run */
   GLuint inputs[2];		  /* VERT_* inputs to pipeline */
   struct tnl_pipeline_stage stages[MAX_PIPELINE_STAGES+1];
   GLuint nr_stages;
};


struct tnl_eval_store {
   GLuint EvalMap1Flags;
   GLuint EvalMap2Flags;
   GLuint EvalMap1AttribFlags;  /* GL_NV_vertex_program */
   GLuint EvalMap2AttribFlags;  /* GL_NV_vertex_program */
   GLuint EvalNewState;
};


typedef void (*point_func)( GLcontext *ctx, GLuint v1 );
typedef void (*line_func)( GLcontext *ctx, GLuint v1, GLuint v2 );
typedef void (*triangle_func)( GLcontext *ctx,
                               GLuint v1, GLuint v2, GLuint v3 );
typedef void (*quad_func)( GLcontext *ctx, GLuint v1, GLuint v2,
                           GLuint v3, GLuint v4 );
typedef void (*render_func)( GLcontext *ctx, GLuint start, GLuint count,
			     GLuint flags );
typedef void (*interp_func)( GLcontext *ctx,
			     GLfloat t, GLuint dst, GLuint out, GLuint in,
			     GLboolean force_boundary );
typedef void (*copy_pv_func)( GLcontext *ctx, GLuint dst, GLuint src );
typedef void (*setup_func)( GLcontext *ctx,
			    GLuint start, GLuint end,
			    GLuint new_inputs);


struct tnl_device_driver {
   /***
    *** TNL Pipeline
    ***/

   void (*RunPipeline)(GLcontext *ctx);
   /* Replaces PipelineStart/PipelineFinish -- intended to allow
    * drivers to wrap _tnl_run_pipeline() with code to validate state
    * and grab/release hardware locks.  
    */

   void (*NotifyMaterialChange)(GLcontext *ctx);
   /* Alert tnl-aware drivers of changes to material.
    */


   /***
    *** Rendering -- These functions called only from t_vb_render.c
    ***/
   struct {
      void (*Start)(GLcontext *ctx);
      void (*Finish)(GLcontext *ctx);
      /* Called before and after all rendering operations, including DrawPixels,
       * ReadPixels, Bitmap, span functions, and CopyTexImage, etc commands.
       * These are a suitable place for grabbing/releasing hardware locks.
       */

      void (*PrimitiveNotify)(GLcontext *ctx, GLenum mode);
      /* Called between RenderStart() and RenderFinish() to indicate the
       * type of primitive we're about to draw.  Mode will be one of the
       * modes accepted by glBegin().
       */

      interp_func Interp;
      /* The interp function is called by the clipping routines when we need
       * to generate an interpolated vertex.  All pertinant vertex ancilliary
       * data should be computed by interpolating between the 'in' and 'out'
       * vertices.
       */

      copy_pv_func CopyPV;
      /* The copy function is used to make a copy of a vertex.  All pertinant
       * vertex attributes should be copied.
       */

      void (*ClippedPolygon)( GLcontext *ctx, const GLuint *elts, GLuint n );
      /* Render a polygon with <n> vertices whose indexes are in the <elts>
       * array.
       */

      void (*ClippedLine)( GLcontext *ctx, GLuint v0, GLuint v1 );
      /* Render a line between the two vertices given by indexes v0 and v1. */

      point_func            Point;
      line_func             Line;
      triangle_func         Triangle;
      quad_func             Quad;
      /* These functions are called in order to render points, lines,
       * triangles and quads.  These are only called via the T&L module.
       */

      render_func          *PrimTabVerts;
      render_func          *PrimTabElts;
      /* Render whole unclipped primitives (points, lines, linestrips,
       * lineloops, etc).  The tables are indexed by the GL enum of the
       * primitive to be rendered.  RenderTabVerts is used for non-indexed
       * arrays of vertices.  RenderTabElts is used for indexed arrays of
       * vertices.
       */

      void (*ResetLineStipple)( GLcontext *ctx );
      /* Reset the hardware's line stipple counter.
       */

      setup_func BuildVertices;
      /* This function is called whenever new vertices are required for
       * rendering.  The vertices in question are those n such that start
       * <= n < end.  The new_inputs parameter indicates those fields of
       * the vertex which need to be updated, if only a partial repair of
       * the vertex is required.
       *
       * This function is called only from _tnl_render_stage in tnl/t_render.c.
       */
      

      GLboolean (*Multipass)( GLcontext *ctx, GLuint passno );
      /* Driver may request additional render passes by returning GL_TRUE
       * when this function is called.  This function will be called
       * after the first pass, and passes will be made until the function
       * returns GL_FALSE.  If no function is registered, only one pass
       * is made.
       *
       * This function will be first invoked with passno == 1.
       */
   } Render;
};

union uif { GLuint ui; GLfloat f; };

/* Want to keep a cache of these around.  Each is parameterized by
 * only a single value which has only a small range.  Only expect a
 * few, so just rescan the list each time?
 */
struct dynfn {
   struct dynfn *next, *prev;
   int key;
   char *code;
};

#define TNL_BEGIN 0x0
#define TNL_END   0x1
#define TNL_BE_MAX 3		/* XXX */

struct tnl_vtx {
   int initial_counter;		
   int counter;			        /* nr of vertices  */
   int vertex_size;
   union uif *vbstart;		        /* built vertices */
   union uif *vbptr;		        /* built vertices */
   union uif *attrptr[TNL_ATTRIB_MAX]; /* pointers into vertex below */
   union uif vertex[TNL_ATTRIB_MAX*4]; /* current vertex */

   GLubyte attrib_sz[TNL_ATTRIB_MAX];
   
   struct dynfn *generated[4][2][2]; /* chains of generated functions
					* could use a hash also.
					*/

   struct dynfn *(*codegen[4][2][2])( GLcontext *ctx, int key );


   /* Second level dispatch table for MultiTexCoord, Material and 
    * VertexAttribNV.
    *
    * Need this because we want to track things like vertex attribute
    * sizes, presence/otherwise of attribs in recorded vertices, etc, by
    * manipulating the state of dispatch tables.  Need therefore a
    * dispatch slot for each value of 'index' or 'unit' in VertexAttribNV
    * and MultiTexCoordARB.  Also need a mechnism for keeping this data
    * consistent with what's coming in via the Vertex/Normal/etc api
    * above (where aliasing exists with the traditional entrypoints).
    * Note that MultiTexCoordARB aliases with TexCoord when unit==0.
    *
    * Need presence tracking for material components, too, but not size
    * tracking or help with aliasing.  Could move material to seperate
    * dispatch without the "*4" below, or even do the checks every time.
    */
   void (*tabfv[4][TNL_ATTRIB_MAX])( const GLfloat * );

   /* Build a list of begins and ends.
    */
   struct { GLint type; GLint idx; GLenum mode; } be[TNL_BE_MAX];
   GLint be_count;
};
   

typedef struct {

   /* Driver interface.
    */
   struct tnl_device_driver Driver;
   
   /* Support for vertex assembly from begin/end objects:
    */
   struct tnl_vtx vtx;

   /* Track whether the module is active.
    */
   GLboolean bound_exec;

   /* Display list extensions
    */
   GLuint opcode_vertex_block;

   /* Pipeline
    */
   struct tnl_pipeline pipeline;
   struct vertex_buffer vb;

   /* Probably need a better configuration mechanism:
    */
   GLboolean NeedNdcCoords;
   GLboolean IsolateMaterials;

   /* Derived state and storage for _tnl_eval_vb:
    */
   struct tnl_eval_store eval;

   /* We have our own dispatch table for EXECUTE modes.  In COMPILE
    * and COMPILE_AND_EXECUTE, we plug directly into ctx->Save?
    * 
    */
   struct _glapi_table *Exec;	/* Execute funcs */

} TNLcontext;



#define TNL_CONTEXT(ctx) ((TNLcontext *)(ctx->swtnl_context))
#define TNL_CURRENT_IM(ctx) ((struct immediate *)(ctx->swtnl_im))


#define TYPE_IDX(t) ((t) & 0xf)
#define MAX_TYPES TYPE_IDX(GL_DOUBLE)+1      /* 0xa + 1 */

extern void _tnl_MakeCurrent( GLcontext *ctx,
			      GLframebuffer *drawBuffer,
			      GLframebuffer *readBuffer );


/*
 * Macros for fetching current input buffer.
 */
#ifdef THREADS
#define GET_IMMEDIATE  struct immediate *IM = TNL_CURRENT_IM(((GLcontext *) (_glapi_Context ? _glapi_Context : _glapi_get_context())))
#define SET_IMMEDIATE(ctx, im)  ctx->swtnl_im = (void *)im
#else
extern struct immediate *_tnl_CurrentInput;
#define GET_IMMEDIATE struct immediate *IM = _tnl_CurrentInput
#define SET_IMMEDIATE(ctx, im)			\
do {						\
   ctx->swtnl_im = (void *)im;			\
   _tnl_CurrentInput = im;			\
} while (0)
#endif


#endif
