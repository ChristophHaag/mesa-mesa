#*************************************************************************
# Copyright 2008 Tungsten Graphics, Inc., Cedar Park, Texas.
# All Rights Reserved.
#*************************************************************************


import sys, os
import apiutil

######################################################################
# Version-specific values to be used in the main script
# header: which header file to include
# api: what text specifies an API-level function
# special: the name of the "specials" file
VersionSpecificValues = {
    'GLES1.1' : {
        'description' : 'GLES1.1 extension functions',
        'header' : 'GLES/gl.h',
        'extheader' : 'GLES/glext.h',
    },
    'GLES2.0': {
        'description' : 'GLES2.0 extension functions',
        'header' : 'GLES2/gl2.h',
        'extheader' : 'GLES2/gl2ext.h',
    }
}

######################################################################
# Main code for the script begins here.

# Get the name of the program (without the directory part) for use in
# error messages.
program = os.path.basename(sys.argv[0])

# We assume that the directory that the Python script is in also
# houses the "special" files.
programDir = os.path.dirname(sys.argv[0])

# Set default values
verbose = 0
functionList = "APIspec.txt"
version = "GLES1.1"

# Allow for command-line switches
import getopt, time
options = "hvV:S:"
try:
    optlist, args = getopt.getopt(sys.argv[1:], options)
except getopt.GetoptError, message:
    sys.stderr.write("%s: %s.  Use -h for help.\n" % (program, message))
    sys.exit(1)

for option, optarg in optlist:
    if option == "-h":
        sys.stderr.write("Usage: %s [-%s]\n" % (program, options))
        sys.stderr.write("Parse an API specification file and generate the _glapi_get_proc_address function\n")
        sys.stderr.write("-h gives help\n")
        sys.stderr.write("-v is verbose\n")
        sys.stderr.write("-V specifies GLES version to generate [%s]:\n" % version)
        for key in VersionSpecificValues.keys():
            sys.stderr.write("    %s - %s\n" % (key, VersionSpecificValues[key]['description']))
        sys.stderr.write("-S specifies API specification file to use [%s]\n" % functionList)
        sys.exit(1)
    elif option == "-v":
        verbose += 1
    elif option == "-V":
        version = optarg
    elif option == "-S":
        functionList = optarg

# Beyond switches, we support no further command-line arguments
if len(args) >  0:
    sys.stderr.write("%s: only switch arguments are supported - use -h for help\n" % program)
    sys.exit(1)

# If we don't have a valid version, abort.
if not VersionSpecificValues.has_key(version):
    sys.stderr.write("%s: version '%s' is not valid - use -h for help\n" % (program, version))
    sys.exit(1)

# If we get to here, we're good to go.  The "version" parameter
# directs GetDispatchedFunctions to only allow functions from
# that "category" (version in our parlance).  This allows 
# functions with different declarations in different categories
# to exist (glTexImage2D, for example, is different between
# GLES1 and GLES2).
keys = apiutil.GetAllFunctions(functionList, version)

print """/* DO NOT EDIT *************************************************
 * THIS FILE AUTOMATICALLY GENERATED BY THE %s SCRIPT
 * API specification file:   %s
 * GLES version:             %s
 * date:                     %s
 */
""" % (program, functionList, version, time.strftime("%Y-%m-%d %H:%M:%S"))

# The headers we choose are version-specific.
print """
#include <string.h>

/* We need to define this to get prototypes for the extension functions. */
#define GL_GLEXT_PROTOTYPES

#include "%s"
#include "%s"
#include "st_platform.h"
""" % (VersionSpecificValues[version]['header'], VersionSpecificValues[version]['extheader'])

# We can't include mesa/glapi/glapi.h because its symbols conflict with
# the GLES2 symbols.  We really only need a typedef and an extern.
print """
typedef void (*_glapi_proc)(void); /* generic function pointer */
_glapi_proc 
_glapi_get_proc_address(const char *funcName);
"""

# Start off our function table.
print """
static const struct {
   const char *name;
   _glapi_proc proc;
} procs[] = {"""

# Now run through all the functions we have, looking for procedure
# addresses to emit.
for funcName in keys:
    if verbose > 0: sys.stderr.write("%s: processing function %s\n" % (program, funcName))

    # According to the EGL spec, we only emit GetProcAddress()
    # addresses for functions that are, or were, extensions,
    # whether or not those functions are required extensions
    # and whether or not they've entered the core.  We can
    # check whether this function exists as an extension for
    # the given version of the API by looking at its category labels.
    # For an extension, the label will be of the form
    # "GLES1.1:OES_extension_name", for example.
    extensionName = None
    for c in apiutil.Categories(funcName):
        categorySpec = c.split(":")
        if categorySpec[0] == version and len(categorySpec) > 1:
            extensionName = categorySpec[1]
            break

    if not extensionName:
        if verbose > 0: sys.stderr.write("%s: ignoring function %s because it's not a part of any extensions\n" % (program, funcName))
        continue

    # Calculate the extension suffix, given the extension name.
    # An extension of OES_blah would require a suffix of "OES",
    # where an extension of APPLE_blah would require a suffix of
    # "APPLE".
    extensionSuffix = extensionName.split("_")[0]

    # Spit out the line we need.
    print '    {"gl%s%s", (_glapi_proc) gl%s%s}, /* %s */' % (funcName, extensionSuffix, funcName, extensionSuffix, extensionName)

    # Well, that was easy.

# end for each function

# Finish up the table, and add the source for the get_proc_address
# function.
print """};

_glapi_proc 
_glapi_get_proc_address(const char *funcName)
{
   unsigned int i;
   for (i = 0; i < sizeof(procs)/sizeof(procs[0]); i++) {
      if (!strcmp(funcName, procs[i].name))
         return procs[i].proc;
   }
   return NULL;
}
"""

# All done!
