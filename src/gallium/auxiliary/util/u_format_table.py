#!/usr/bin/env python

'''
/**************************************************************************
 *
 * Copyright 2008 Tungsten Graphics, Inc., Cedar Park, Texas.
 * All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sub license, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice (including the
 * next paragraph) shall be included in all copies or substantial portions
 * of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
 * IN NO EVENT SHALL TUNGSTEN GRAPHICS AND/OR ITS SUPPLIERS BE LIABLE FOR
 * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 **************************************************************************/
'''


import sys


UNSIGNED, SIGNED, FIXED, FLOAT = 'u', 's', 'h', 'f'


class Type:
    
    def __init__(self, kind, norm, size):
        self.kind = kind
        self.norm = norm
        self.size = size

    def __str__(self):
        s = str(self.kind)
        if norm:
            s += 'n'
        s += str(self.size)
        return s


SCALED, NORM, SRGB = 'scaled', 'norm', 'srgb'


class Format:

    def __init__(self, name, layout, block_width, block_height, in_types, out_swizzle, colorspace):
        self.name = name
        self.layout = layout
        self.block_width = block_width
        self.block_height = block_height
        self.in_types = in_types
        self.out_swizzle = out_swizzle
        self.name = name
        self.colorspace = colorspace

    def __str__(self):
        return self.name

    def block_size(self):
        size = 0
        for type in self.in_types:
            size += type.size
        return size


def parse(filename):
    stream = open(filename)
    formats = []
    for line in stream:
        line = line.rstrip()
        fields = [field.strip() for field in line.split(',')]
        name = fields[0]
        layout = fields[1]
        block_width, block_height = map(int, fields[2:4])
        in_types = []
        for field in fields[4:8]:
            if field:
                kind = field[0]
                if field[1] == 'n':
                    norm = True
                    size = int(field[2:])
                else:
                    norm = False
                    size = int(field[1:])
            else:
                kind = ''
                norm = False
                size = 0
            in_type = Type(kind, norm, size)
            in_types.append(in_type)
        out_swizzle = fields[8]
        colorspace = fields[9]
        formats.append(Format(name, layout, block_width, block_height, in_types, out_swizzle, colorspace))
    return formats


def layout_map(layout):
    return 'UTIL_FORMAT_LAYOUT_' + str(layout).upper()


layout_channels_map = {
    'rgba': 'rgba',
    'zs': 'zs',
    'yuv': ['y1', 'y2', 'u', 'v'],
    'dxt': []
}


kind_map = {
    '': "UTIL_FORMAT_TYPE_VOID",
    'x': "UTIL_FORMAT_TYPE_VOID",
    UNSIGNED: "UTIL_FORMAT_TYPE_UNSIGNED",
    SIGNED: "UTIL_FORMAT_TYPE_SIGNED",
    FIXED: "UTIL_FORMAT_TYPE_FIXED",
    FLOAT: "UTIL_FORMAT_TYPE_FLOAT",
}


def bool_map(value):
    if value:
        return "TRUE"
    else:
        return "FALSE"


swizzle_map = {
    'x': "UTIL_FORMAT_SWIZZLE_X",
    'y': "UTIL_FORMAT_SWIZZLE_Y",
    'z': "UTIL_FORMAT_SWIZZLE_Z",
    'w': "UTIL_FORMAT_SWIZZLE_W",
    '0': "UTIL_FORMAT_SWIZZLE_0",
    '1': "UTIL_FORMAT_SWIZZLE_1",
    '_': "UTIL_FORMAT_SWIZZLE_NONE",
}


def write_format_table(formats):
    print '/* This file is autogenerated by u_format_table.py from u_format.csv. Do not edit directly. */'
    print
    # This will print the copyright message on the top of this file
    print __doc__.strip()
    print
    print '#include "u_format.h"'
    print
    print 'const struct util_format_description'
    print 'util_format_description_table[] = '
    print "{"
    for format in formats:
        print "   {"
        print "      %s," % (format.name,)
        print "      \"%s\"," % (format.name,)
        print "      {%u, %u, %u}, /* block */" % (format.block_width, format.block_height, format.block_size())
        print "      %s," % (layout_map(format.layout),)
        print "      {"
        for i in range(4):
            type = format.in_types[i]
            if i < 3:
                sep = ","
            else:
                sep = ""
            print "         {%s, %s, %u}%s /* %s */" % (kind_map[type.kind], bool_map(type.norm), type.size, sep, "xyzw"[i])
        print "      },"
        print "      {"
        for i in range(4):
            swizzle = format.out_swizzle[i]
            if i < 3:
                sep = ","
            else:
                sep = ""
            try:
                comment = layout_channels_map[format.layout][i]
            except:
                comment = 'ignored'
            print "         %s%s /* %s */" % (swizzle_map[swizzle], sep, comment)
        print "      },"
        print "      UTIL_FORMAT_COLORSPACE_RGB,"
        print "   },"
    print "   {"
    print "      PIPE_FORMAT_NONE,"
    print "      \"PIPE_FORMAT_NONE\","
    print "      {0, 0, 0},"
    print "      0,"
    print "      {{0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}},"
    print "      {0, 0, 0, 0},"
    print "      0"
    print "   },"
    print "};"


def main():

    formats = []
    for arg in sys.argv[1:]:
        formats.extend(parse(arg))
    write_format_table(formats)


if __name__ == '__main__':
    main()
